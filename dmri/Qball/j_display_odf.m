function varargout = j_display_odf(odf,varargin)
% =========================================================================
% FUNCTION
% j_display_odf.m
%
% 
% INPUTS (facultative options are in brackets)
% -------------------------------------------------------------------------
% odf				nx*ny*nsh (float)	1D, 2D or 3D matrix containing SH
%										coefficients of the ODF, or
%										amplitude values
% 
% *** OPTIONS: (to be specified like: 'option_name','option_value').
% 
% (coord)			char				'sh', 'amp', 'tensor'. Format of odf: could
%										be in spherical harmonics (sh)
%										or amplitude on a sphere (amp), or
%										tensor (nx6).
%										Default='amp'
% 
% (scheme)			struct or nx3		Either a structure generated by
%										j_gen_scheme.m, or a nx3 matrix.
% 
% (flipodf)			1*3 signed int		permute dimensions if ODF is badly
%										oriented. Example: [1 -3 2].
%										Default is [1 2 3].
% 
% (max_odf)			nx*ny*3 cell		Contains parametric description of
%										ODF maxima. Note that it is
%										possible to input a nx*ny*nb*3
%										matrix, nb being the number of
%										bootstrap samples, so that each of
%										them are displayed on the figure
%										(in that case the linewidth is
%										thinner).
% 
% (max_color)		string				'fixed','directional'. Color of the
%										maxima
%
% (linewidth)		integer				linewidth of ODF maxima
%
% (overlay)			nx*ny				FA, GFA or whatever to be overlaid
%										by ODF. By defalut the input is 
%										scaled between 0 and 1.
% 
% (marker)			1xn (integer)		mark these plots on the ODF (for
%										debugging purpose)
% 
% (normalize)		binary				Normalize ODF shape (default=1)
% 
% (show_odf)		binary				You can choose NOT to display the
%										ODF, if you wish to display only
%										the GFA or the maxima
% 
% (show_sampling)	binary				Show discrete sampling on the sphere (default=0)
%
% (xmin)			integer				to display only a portion of the 2D matrix. You can obtain xmin, xmax, ymin and ymax on the gfa map generated by j_dmri_bootstrap_statistic for instance. 
% (xmax)			integer				to display only a portion of the 2D matrix
% (ymin)			integer				to display only a portion of the 2D matrix
% (ymax)			integer				to display only a portion of the 2D matrix
% 
% 
% OUTPUTS
% -------------------------------------------------------------------------
% h_fig				float				Matlab figure handle
%
% 
% Author: Julien Cohen-Adad <jcohen@nmr.mgh.harvard.edu>
% Created: 2011-02-21
% Modified: 2011-09-15: allows to display only one ODF
% =========================================================================


dbstop if error

% default parameters
coord				= 'amp';
normalize_odf		= 1;
order_visu			= 12;
show_odf			= 1;
show_sampling		= 0;
is_overlay			= 0;
max_color			= 'directional';
max_fixed_values	= ['g','r','b','y','c'];
linewidth			= 3;
nb_bootstraps		= 0;
flipodf				= [1 2 3];

% check options
for i = 1:nargin-2
	if strcmp(varargin{i},'scheme'), scheme = varargin{i+1}; end
	if strcmp(varargin{i},'overlay'), overlay = varargin{i+1}; is_overlay = 1; end
	if strcmp(varargin{i},'xmin'), ymin = varargin{i+1}; end
	if strcmp(varargin{i},'xmax'), ymax = varargin{i+1}; end
	if strcmp(varargin{i},'ymin'), xmin = varargin{i+1};end
	if strcmp(varargin{i},'ymax'), xmax = varargin{i+1};end
	if strcmp(varargin{i},'coord'), coord = varargin{i+1};	end
	if strcmp(varargin{i},'max_odf'), max_odf = varargin{i+1}; end
	if strcmp(varargin{i},'marker'), marker = varargin{i+1}; end
	if strcmp(varargin{i},'normalize'), normalize_odf = varargin{i+1}; end
	if strcmp(varargin{i},'show_odf'), show_odf = varargin{i+1}; end
	if strcmp(varargin{i},'show_sampling'), show_sampling = varargin{i+1}; end
	if strcmp(varargin{i},'max_color'), max_color = varargin{i+1}; end
	if strcmp(varargin{i},'linewidth'), linewidth = varargin{i+1}; end
	if strcmp(varargin{i},'nb_bootstraps'), nb_bootstraps = varargin{i+1}; end
	if strcmp(varargin{i},'submask'), submask = varargin{i+1}; end
	if strcmp(varargin{i},'flipodf'), flipodf = varargin{i+1}; end
end

% initialization
% xmin = 1;
% xmax = 1;
% ymin = 1;
% ymax = 1;
one_odf_to_display = 0;

% check input size
if size(odf==4)
	odf = squeeze(odf);
end

% check input size
nb_dims = length(size(odf));
if nb_dims == 2
	if ~isempty(find(size(odf)==1))
		% there is only one ODF to display
		nx = 1;
		ny = 1;
		nq = length(odf);
% 		odf3=reshape(odf,1,1,nq);
		one_odf_to_display = 1;
	else
		% there is a line of ODF to display
		if ~exist('nx')
			nx = size(odf,1);
		end
		ny = 1;
		nq = size(odf,2);
		odf = reshape(odf,nx,1,nq);
	end	
elseif nb_dims==3
	if ~exist('xmin')
		xmin = 1;
		xmax = size(odf,1);
	end
	if ~exist('ymin')
		ymin = 1;
		ymax = size(odf,2);
	end
	nx = xmax-xmin+1;
	ny = ymax-ymin+1;
	nq = size(odf,3);
	
	% crop odf according to user parameter
	odf = odf(xmin:xmax,ymin:ymax,:);

	% crop overlay according to user parameter
	if is_overlay
		overlay = overlay(xmin:xmax,ymin:ymax,:);
	end

	% crop maxima according to user parameter
	if exist('max_odf')
		max_odf = max_odf(xmin:xmax,ymin:ymax,:);
	end
end

% if no submask has been prescribed, display everything
if ~exist('submask')
	submask = ones(nx,ny);
end

% display ODF
j_progress('Display ODF ...................................')
iv=1;
% ratio_xy = nx/ny;
ratio_xy = ny/nx;
h_fig = figure;
% h_fig = figure('ResizeFcn',@figResize);

fig_pos = get(h_fig,'Position');
fig_pos(4) = fig_pos(3)/ratio_xy;
% adjust size in native resolution of the screen
snx = round(fig_pos(3)/nx);
fig_pos(3) = snx*nx;
sny = round(fig_pos(4)/ny);
fig_pos(4) = sny*ny;
set(h_fig,'Position',fig_pos);
set(h_fig,'color','white'); % sets the color to white
set(h_fig,'InvertHardCopy','off'); % to save background color


% NESTED FUNCTION: Figure resize function
% function figResize(src,evt)
%     fig_pos = get(h_fig,'Position');
% 	% check at which border the maximum size be set (X or Y)
% 	if ( nx/ny >= fig_pos(3)/fig_pos(4) )
% 		% constrained by Y
% 		fig_pos(4) = fig_pos(3)/ratio_xy;
% 	else
% 		% constrained by X
% 		fig_pos(3) = fig_pos(4)*ratio_xy;
% 	end
% 	% adjust size in native resolution of the screen
% 	snx = round(fig_pos(3)/nx);
% 	fig_pos(3) = snx*nx;
% 	sny = round(fig_pos(4)/ny);
% 	fig_pos(4) = sny*ny;
% 	set(h_fig,'Position',fig_pos);	
% end

% check if GFA exists
% if exist('overlay')
% 	min_gfa = min(min(gfa));
% 	max_gfa = max(max(gfa));
% 	if min_gfa==max_gfa
% 		overlay_gfa=0; 
% 	end
% else
% 	overlay_gfa=0;
% end

% normalize overlay
if is_overlay
	overlay_n = (overlay-min(min(overlay)))/max(max(overlay));
else
	overlay_n = ones(nx,ny);
end


for ix=1:nx
	for iy=1:ny
		dx = 1/nx;
		dy = 1/ny;
		% get the voxel
		h_axes = subplot('Position',[1-iy*dy (ix-1)*dx dy dx]);
% 		h_axes = subplot('Position',[(iy-1)*dy 1-ix*dx dy dx]);

		% diplay background
		image([-0.35 0.35],[-0.35 0.35],overlay_n(ix,iy)*64)
		colormap gray
% 		set(h_axes,'NextPlot','new')
		set(h_axes,'Layer','bottom')
		set(h_axes,'DrawMode','fast')
		set(h_axes,'LineWidth',0.01)
		set(h_axes,'XTick',[])
		set(h_axes,'YTick',[])
		set(h_axes,'XColor',[overlay_n(ix,iy) overlay_n(ix,iy) overlay_n(ix,iy)])
		set(h_axes,'YColor',[overlay_n(ix,iy) overlay_n(ix,iy) overlay_n(ix,iy)])
% set(h_axes,'TightInset',[0 0 0 0]);
%  		set(h_axes,'visible','off');

		
		
		% -----------------------------------------------------------------
		%		TENSOR
		% -----------------------------------------------------------------
		if strcmp(coord,'tensor')
			
			% get cartesian value of the tensor for that scheme
			x = scheme.vert;
			D = [odf(ix,iy,1) odf(ix,iy,2) odf(ix,iy,3);odf(ix,iy,2) odf(ix,iy,4) odf(ix,iy,5);odf(ix,iy,3) odf(ix,iy,5) odf(ix,iy,6)];
			% D is a 1x6 matrix
			% x is a nx3 matrix
			nq = size(x,1);
			for isphere=1:nq
				value_sphere(isphere) = exp(3000*x(isphere,:)*D*x(isphere,:)');
			end
			% normalize values
			value_sphere=value_sphere/max(value_sphere);
			
			% compute FA
			if overlay_fa
				[evec eval] = eig(D);
				trd3 = sum(eval);
				gfan = (sqrt(3)/sqrt(2))*sqrt((eval-trd3)^2+(eval-trd3)^2+(eval-trd3)^2)/(sqrt(eval^2+eval^2+eval^2));
			else
				gfan = 0;
			end
			
			[h_patch V] = j_plot_amp(value_sphere',scheme,[ 1 1 0 ],1,gfan);
			
% 			
% 			[vect val] = eig([odf(ix,iy,1) odf(ix,iy,2) odf(ix,iy,3);odf(ix,iy,2) odf(ix,iy,4) odf(ix,iy,5);odf(ix,iy,3) odf(ix,iy,5) odf(ix,iy,6)]);
% 			V = [scheme.vert(:,1).* vect(1,1)*val(1) scheme.vert(:,2).* vect(2,1)*val(2) scheme.vert(:,3).* vect(3,1)*val(3)];
% % 			V = [scheme.vert(:,1).* vect(1) scheme.vert(:,2).* vect(2) scheme.vert(:,3).* vect(3)];
% 			colour = [1 1 0];%std(eigenval)./sqrt(mean(eigenval.^2)); colour = [colour 0 1-colour];
% 			range = 1.5*max(V(:));
% 				set(gcf, 'Color', [1 1 1], ...
% 						 'DefaultAxesCameraTarget', [ 0 0 0 ], ...
%  						 'DefaultAxesVisible', 'on', ...
% 						 'DefaultAxesBox', 'on', ...
% 						 'DefaultAxesCameraPosition', 6*range*[0 0 1], ...
% 						 'DefaultAxesXLim', [ -range range ], ...
% 						 'DefaultAxesYLim', [ -range range ], ...
% 						 'DefaultAxesZLim', [ -range range ]);
% % 						 'DefaultAxesCameraViewAngle', 20, ...
% % 						 'DefaultAxesCameraViewAngleMode', 'manual', ...
% 
% 				h = patch('Vertices', V, 'Faces', scheme.mesh); 
% 				set(h, 'LineStyle', 'None', ...
% 					'FaceLighting', 'Phong', ...
% 					'FaceColor', colour);
% 
% 				light('position', [1 1 1]);
		else
			
			% -----------------------------------------------------------------
			%		ODF
			% -----------------------------------------------------------------
			
			if strcmp(coord,'sh')
				if one_odf_to_display
					odfa = j_SH2amp(double(odf),scheme)';
				else
					odfa = j_SH2amp(double(squeeze(odf(ix,iy,:))),scheme);
				end
			elseif strcmp(coord,'amp')
				if one_odf_to_display
					odfa = double(odf)';
				else
					odfa = double(squeeze(odf(ix,iy,:)));
				end					
			end

			% normalize ODF
			if normalize_odf
				odfn=odfa-min(odfa);
				odfn=odfn/max(odfn);
			else
				odfn=odfa/max(odfa);
			end

			% display the ODF			
			if ( show_odf & logical(submask(ix,iy)) )
				if ~exist('scheme')
					% generate scheme
					scheme = j_gen_scheme(length(odfn),order_visu);
				end
				[h_patch V] = plot_odf(odfn,scheme,[ 1 1 0 ],1,flipodf);
			end			
			
			% display ODF maxima
			if exist('max_odf')
				% check if we have several bootstrap maxima
				if ~iscell(max_odf{1,1}(1))

				% ONLY ONE SET OF MAXIMA
					
					% loop over maxima
					nb_maxima = size(max_odf{ix,iy},1);
					for imax = 1:nb_maxima
						% draw a line
						norm_max_direction = norm(max_odf{ix,iy}(imax,:));
						coeff = 1.5*inv(norm_max_direction);
						max_direction = max_odf{ix,iy}(imax,:)*coeff;
						if strcmp(max_color,'fixed')
							line_color = max_fixed_values(imax);
						elseif strcmp(max_color,'directional')
							line_color = abs(max_direction/max(abs(max_direction)));
						end
						line([-max_direction(1) max_direction(1)],[-max_direction(2) max_direction(2)],[-max_direction(3) max_direction(3)],'LineWidth',linewidth,'Color',line_color)
	% 					line([0 -max_direction(1)*coeff],[0 max_direction(1)*coeff],[0 max_direction(1)*coeff],'LineWidth',5,'Color','y')
					end
					
				% SEVERAL SETS OF MAXIMA (e.g. bootstrap experiment)	
				else
					
					% reduce the size of the line
% 					linewidth = 0.5;
					if ~nb_bootstraps, nb_bootstraps = size(max_odf{ix,iy},2); end
					for ib=1:nb_bootstraps
						if ~isempty(max_odf{ix,iy})
							% loop over maxima
							nb_maxima = size(max_odf{ix,iy}{ib},1);
							for imax = 1:nb_maxima
								% draw a line
								norm_max_direction = norm(max_odf{ix,iy}{ib}(imax,:));
								coeff = 1.5*inv(norm_max_direction);
								max_direction = max_odf{ix,iy}{ib}(imax,:)*coeff;
								if strcmp(max_color,'fixed')
									line_color = max_fixed_values(imax);
								elseif strcmp(max_color,'directional')
									line_color = abs(max_direction/max(abs(max_direction)));
								end
								line([-max_direction(1) max_direction(1)],[-max_direction(2) max_direction(2)],[-max_direction(3) max_direction(3)],'LineWidth',linewidth,'Color',line_color)
			% 					line([0 -max_direction(1)*coeff],[0 max_direction(1)*coeff],[0 max_direction(1)*coeff],'LineWidth',5,'Color','y')
							end
						end % if ~isempty(max_odf{ix,iy})
					end % for ib
				end	% if ~iscell	
			end
		end
		
		% mark some plots on the ODF
		if exist('marker')
			for imarker = 1:length(marker)
				plot3(V(marker(imarker),1),V(marker(imarker),2),V(marker(imarker),3),'.','MarkerSize',15)
			end
		end

		% show sampling
		if show_sampling
			set(h_patch,'Marker','.');
		end
		
		j_progress(iv/(nx*ny))
		iv = iv+1;
	end
end

varargout{1} = h_fig;


end


% =========================================================================
function [h_patch V] = plot_odf(S, scheme, colour, transparency, flipodf)

% function plot_amp(S, scheme, transparency)
%
% Plot amplitudes 'S' for the set of directions given 
% in 'scheme', with optional colour and transparency
% specified.
%
% background			= value between [0 1]
% 
% original from maxime descoteaux, modified by julien cohen-adad

if ~exist('colour')
  colour = [ 1 1 0 ];
end

if ~exist('transparency') 
  transparency = 1;
end

% if ~exist('background') 
%   background = 1;
% end

range = 1.5*max(S);
negcolour = [ 1 1 1 ];

%clf
% set(gcf, 'Color', [background background background], ...
%          'DefaultAxesCameraViewAngleMode', 'manual', ...
%          'DefaultAxesCameraViewAngle', 20, ...
%          'DefaultAxesCameraTarget', [ 0 0 0 ], ...
%          'DefaultAxesCameraPosition', 6*range*[0 0 1], ...
%          'DefaultAxesVisible', 'on', ...
%          'DefaultAxesBox', 'on', ...
%          'DefaultAxesXLim', [ -range range ], ...
%          'DefaultAxesYLim', [ -range range ], ...
%          'DefaultAxesZLim', [ -range range ]);

% S2 = -S;
S(find(S<0)) = 0;
% S2(find(S2<0)) = 0;

% scheme.vert(:,2) = -scheme.vert(:,2);
% scheme.mesh(:,2) = -scheme.mesh(:,2);

% check if scheme is a structure or a nx3 matrix
if isstruct(scheme)
	V = scheme.vert .* (S*[ 1 1 1 ]);
	scheme_mesh = scheme.mesh;
else
	V = scheme .* (S*[ 1 1 1 ]);
	scheme_mesh = convhulln(scheme);
end

V2 = V;

for i=1:3
	V2(:,i) = sign(flipodf(i))*V(:,abs(flipodf(i)));
end

h_patch = patch('Vertices', V2, 'Faces', scheme_mesh); 
set(h_patch, 'LineStyle', 'None', ...
    'FaceLighting', 'Phong', ...
    'FaceColor', colour, ...
    'FaceAlpha', transparency,...
	'BackFaceLighting','unlit',...
 	'AmbientStrength',0.8);

% color + light
cdata = abs(V2);
axis equal
set(h_patch,'FaceVertexCData',cdata)
set(h_patch,'FaceColor','interp');

if ( sign(flipodf(1)) == -1 )
	light('position', [-1 1 1],'Style','infinite');
	set(h_patch,'BackFaceLighting','reverselit');
elseif ( sign(flipodf(2)) == -1 )
	light('position', [1 -1 1],'Style','infinite');
	set(h_patch,'BackFaceLighting','reverselit');
elseif ( sign(flipodf(3)) == -1 )
	light('position', [1 -1 1],'Style','infinite');
	set(h_patch,'BackFaceLighting','reverselit');
else
	light('position', [1 1 1],'Style','infinite');
end

hold on
end



